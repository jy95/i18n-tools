import fs, { PathLike } from "fs";
import path from "path";

// lodash methodes
import isObject from "lodash/isObject";
import groupBy from "lodash/groupBy";
import flattenDeep from "lodash/flattenDeep";
import reduce from "lodash/reduce";
import get from "lodash/get";

// For typings
import type { Argv } from "yargs";
import { CommonExportArguments, I18N_Merged_Data } from "../../types/exportTypes"
type I18N_Object = { [x: string]: string | Array<any> | I18N_Object }
type I18N_Result = {
    "technical_key": string,
    "label": string,
    "locale": string
}[]

// middelware
import { parsePathToJSON } from "../../middlewares/middlewares";

// configure export commands with the common options in the builder step
export function setUpCommonsOptions(y: Argv) {
    return y
        .option("files", {
            describe: "Path to a JSON object that have as key an unique identifier and value the absolute path to a i18n file, such as : { \"FR\": \"/somePath/fr.json\", \"NL\": \"/somePath/nl.json\"}",
            demandOption: true
        })
        .option("filename", {
            type: "string",
            alias: "of",
            describe: "Name of the output file generated by this CLI (without extension)"
        })
        .option("outputDir", {
            type: "string",
            alias: "od",
            describe: "Output folder where to store the output file",
            default: process.cwd()
        })
        // default value for filename
        .default("filename", function() {
            const date = new Date();
            const timestamp = `${date.getDay() + 1}-${date.getMonth() + 1}-${date.getFullYear()} ${date.getHours()}h${date.getMinutes()}m${date.getSeconds()}`;
            return `translations_${timestamp}`;
        })
        .config('settings', function (configPath) {
            return JSON.parse(fs.readFileSync(configPath, 'utf-8'))
        })
        // coerce files into Object
        .middleware(parsePathToJSON("files"), true)
        // coerce path provided by outputDir
        .coerce(["outputDir"], path.resolve)

        /*
        // validation for filename option
        // validation(s) for files option
        */
}


// turns n i18n file(s) into a merged version
export function merge_i18n_files(argv : CommonExportArguments) : Promise<I18N_Merged_Data> {
    return new Promise( (resolve, reject) => {
        Promise
            // Read files and convert them to useful obj
            .all(
                Object
                    .entries(argv.files)
                    .map(entry => readFile(entry))
            )
            // merge results
            .then(results => mergeResults(results))
            .then(data => resolve(data))
            .catch(err => reject(err));
    });
}

// merge_i18n_files sub functions

// read file and turning into a useful array of objects
function readFile([locale, file_path] : [string, PathLike]) : Promise<I18N_Result> {
    return new Promise((resolve, reject) => {
        fs.promises.readFile(file_path, 'utf8')
            .then(jsonData => Promise.resolve(JSON.parse(jsonData)))
            .then(json => i18n_to_result_format(json, locale))
            .then(result => resolve(result))
            .catch(err => reject(err));        
    });
}

// Get all leaves paths of a object
// Typescript code inspired by https://stackoverflow.com/a/55381003/6149867
function getLeavesPathes(dataObj : any) : string[] {
    const reducer = (aggregator : string[], val : any, key : string) => {
        let paths = [key];
        if(isObject(val)) {
            paths = reduce(val, reducer, []);
            paths = paths.map(path => key + '.' + path);
        }
        aggregator.push(...paths);
        return aggregator;
    };
    const arrayIndexRegEx = /\.(\d+)/gi;
    let paths = reduce(dataObj, reducer, []);
    paths = paths.map(path => path.replace(arrayIndexRegEx, '[$1]'));

    return paths;
}

// turns i18n object to usable format
function i18n_to_result_format(obj : I18N_Object, locale: string) : I18N_Result {
    let leafPaths = getLeavesPathes(obj);
    return leafPaths.map(leafPath => ({
        locale: locale,
        technical_key: leafPath,
        label: get(obj, leafPath) as string
    }));
}

// merge array of {"technical_key": "...", "label": "...", "locale": "..."}
// into {"technical_key": ..., "labels": { "FR": ..., "NL": ..., "DE": ... }}
function mergeResults(results : I18N_Result[]) : Promise<I18N_Merged_Data> {
    const flattenResults = flattenDeep(results);
    let groupBy_technical_key = groupBy(flattenResults,Â 'technical_key');

    let final_result = Object
        .keys(groupBy_technical_key)
        .sort()
        .map(key => {
            return {
                "technical_key": key, 
                "labels": groupBy_technical_key[key]
                    .reduce( (prev : any, curr : any) => {
                        prev[curr["locale"]] = curr["label"];
                        return prev;
                    }, {})
            }
        });
    return Promise.resolve(final_result);
}